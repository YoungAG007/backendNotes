# 操作系统

----

## 第 1 章 计算机系统概述

### 1.1 操作系统的基本概念

#### 1.1.1 操作系统的概念、功能和目标

**1.熟悉的操作系统举例**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**2.操作系统的层次结构**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16366123342492-16366126092359)

**3.操作系统的概念**

* 是系统**最基本最核心的软件，属于系统软件**
* **控制和管理整个计算机的硬件和软件资源**
* 合理的组织、调度计算机的工作与资源的分配
* 为用户和其它软件提供方便的接口和环境
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16366123362434-16366126035028)

**4.操作系统的功能和目标**

- **（1）作为计算机系统资源的管理者**

  - 1️⃣处理器（CPU）管理

    在多道程序环境下，cpu的分配和运行都以进程（或线程）为基本单位，因此对cpu的管理可理解为对进程的管理。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。附上一张图理解对进程的管理。
    ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661261465710)

  - 2️⃣存储器管理

    为多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。
    ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661261762312)

  - 3️⃣文件管理

    计算机中所有的信息都是以文件的形式存在的，操作系统中负责文件的管理的部分称为文件系统，文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。
    ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661261977014)

  - 4️⃣设备管理

    设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓存管理、设备分配、设备处理和虚拟设备等功能。
    ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661262143316)



- **（2）作为用户与计算机硬件系统之间的接口**

  ![image-20211111143838349](操作系统.assets/image-20211111143838349.png)
  - 1️⃣命令接口
    - 命令接口分为两类：联机命令接口和脱机命令接口，用户可以**直接调用**

    - 联机命令接口：又称**交互式命令接口**，适用于分时或实时系统的接口，由一组键盘操作命令组成。用户输入一条指令，操作系统就执行一条指令；
      ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661279877418)
    - 脱机命令接口：又称**批处理接口**，使用于批处理系统，由一组作业控制命令组成。用户输入一堆指令，操作系统运行一堆指令。在操作系统运行这些命令时用户不可干预。 
      批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661280102220)
  - 2️⃣程序接口
    - 程序接口：由**一组系统调用**（也称广义指令）组成
    - 用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，**只能通过用户程序间接调用**
    - 如使用各种外部设备、申请分配和回收内存及其它各种要求
      ![在这里插入图片描述](操作系统.assets/2020022018383578.png)
      动态链接库英文为DLL，是Dynamic Link Library的缩写。DLL是一个包含可由多个程序，同时使用的代码和数据的库。
  - 3、比如常见的图形用户界面程序接口GUI
    ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661295888723)
    ![在这里插入图片描述](操作系统.assets/20200220184339565.png)



**（3）作为扩充机器（虚拟机）**

* 没有任何软件支持的计算机称为裸机	

* 覆盖了软件的机器称为扩充机器或虚拟机

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661296467327)



**总结**

![image-20211111145021078](操作系统.assets/image-20211111145021078.png)



#### 1.1.2 操作系统的特征

* 操作系统是一种系统软件，但与其它系统软件和应用软件有很大的不同，它有自己的特殊性，及基本特征。

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661380266033)



- **1.并发**
  - **并发**：两个或多个事件在同一时间间隔内发生，这些事件在宏观上是同时发生的，**在微观上是交替发生的**， 操作系统的并发性指系统中同时存在着多个运行的程序
  - 并行：两个或多个事件在同一时刻发生
  - 一个单核(CPU)同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）
  - 操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的
  - 在如今的计算机中，一般都是多核cpu的，即在同一时刻可以并行执行多个程序，比如我的**计算机是8核**的，我的计算机可以在同一时刻**并行执行8个程序**，但是事实上我们计算机执行的程序**并不止8个**，因此并发技术是必须存在的，并发性必不可少。
    ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661379920431)



- **2.共享**
  - **资源共享**即共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用

  - 共享分为两类：互斥共享和同时共享

    - （1）**互斥共享**

      计算机中的某个**资源在一段时间内只能允许一个进程访问**，别的进程没有使用权

      临界资源(独占资源)：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享

      举个例子：比如QQ和微信视频。同一段时间内摄像头只能分配给其中一个进程

    - （2）**同时共享**

      计算机中的某个**资源在一段时间内可以同时允许多个进程访问**

      同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”

      **这里的同时指在宏观上是同时的，在微观上是交替进行访问的**，只是cpu处理速度很快，我们感觉不到，在宏观上感觉是在同时进行

      举个例子：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行访问磁盘的，只是时间太短，cpu处理速度太快，我们感觉不到。

      注意：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见

    - （3）**并发性和共享性互为存在条件**

      ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661379442129)



- **3.虚拟**

  虚拟是把一个物理上的实体变为若干逻辑上的对应物。

  物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务

  - 虚拟技术：用于实现虚拟的技术

    **虚拟处理器（CPU）**：通过**多道程序设计技术(宏观上并行、微观上串行)**，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU

    虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器

    虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的

  - 操作系统的虚拟技术科归纳为：

    - 时分复用技术：如处理器的分时共享
    - 空间复用技术：如虚拟存储器
      ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661559145339)



- **4.异步**

  异步：多道程序环境允许多个程序并发执行，但由于资源有限，如cpu只有一个，进程的执行并**不是一贯到底的**，而是**走走停停**的，它以**不可预知的速度**向前推进。

  比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进



### 1.2 操作系统的发展和分类

1.操作系统的分类及其特征优劣

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661558361835)



2.操作系统的发展历程

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163661558718637)

![image-20211111164608532](操作系统.assets/image-20211111164608532.png)



### 1.3 操作系统的运行机制和体系结构

#### 1.3.1 操作系统的运行机制和体系结构

1.操作系统的运行机制和体系结构

![image-20211111200019771](操作系统.assets/image-20211111200019771.png)

![image-20211111201042913](操作系统.assets/image-20211111201042913.png)

![image-20211111200123294](操作系统.assets/image-20211111200123294.png)

![image-20211111200139197](操作系统.assets/image-20211111200139197.png)

2.操作系统内核在计算机系统中的层次结构

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163663692571945)

3.操作系统体系结构类比

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163663692860447)

4.操作系统用户态和核心态的转换

PSW是Program Status Word的缩写

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163663338939043-163663693032949)



#### 1.3.2 中断和异常

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163663336696841-163663693209250)

>发生中断后就需要操作系统介入，开展管理工作（**切换进程执行，用户态-核心态-用户态**），**中断可以使操作系统获得计算机的控制权**

![image-20211111202515016](操作系统.assets/image-20211111202515016.png)



> **内中断：信号来源于CPU内部，与当前执行的指令有关**，外中断与此相反

![image-20211111202537611](操作系统.assets/image-20211111202537611.png)



> 中断处理过程

![image-20211111203906195](操作系统.assets/image-20211111203906195.png)



#### 1.3.3 系统调用

**1.系统调用知识框架图**

> 程序接口就是由一组系统调用组成的，**应用程序可以发出系统调用请求来获得操作系统的服务**

![image-20211111204231855](操作系统.assets/image-20211111204231855.png)

![在这里插入图片描述](操作系统.assets/image-20211111204242732.png)



**2.系统调用和库函数的区别**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163663694111651)

![image-20211111204258949](操作系统.assets/image-20211111204258949.png)



**3.系统调用的执行过程**

![image-20211111204314476](操作系统.assets/image-20211111204314476.png)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163663694534853)

![image-20211111204325864](操作系统.assets/image-20211111204325864.png)



## 第 2 章 进程管理

### 2.1 进程与线程

#### 2.1.1 进程的定义、特征、组成、组织

**1.进程的定义**

（1）程序的概念(指令序列)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16367054837851)

（2）进程的概念

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16367054865613)

* 进程和程序的区别和联系：
  区别：
  (1)**进程是动态的;程序是静态的。**
  (2)进程有独立性，能并发执行;程序不能并发执行。
  (3)二者无一一对应关系。
  (4)进程异步运行，会相互制约;程序不具备此特征。
  但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。
  (5)组成不同。**进程包含进程控制块PCB(Process Control Block)、程序段、数据段。程序包含数据和指令代码**。
  (6)**程序是一个包含了所有指令和数据的静态实体**。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。
  (7)**进程**由程序段、数据段和PCB构成,**会占用系统如CPU(中央处理器central processing unit)、内存等运行资源**。
  (8)**一个程序可以启动多个进程来共同完成**。
  联系：进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。

（3）进程的定义

> 进程是程序的一次执行过程，是资源分配和接受调度的基本单位。

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16367054904415)



**2.进程的特征**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16367054926427)

**3.进程的组成**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16367054949619)

* 而其中最重要的就是**进程控制块PCB**（Process Control Block）

* PCB简介：
          PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。
                PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。
                或者说，**OS是根据PCB来对并发执行的进程进行控制和管理的**。

                例如，当OS要**调度**某进程执行时，要从该进程的PCB中查处其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；
      
               进程在**执行**过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；

  ​       当进程由于某种原因而**暂停**执行时，又须将器断点的处理机环境保存在PCB中。

  ​       可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。

  ​       所以说，**PCB是进程存在的唯一标志**。

PCB通常包含的内容：
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670549764211)

进程的组成：

![image-20211112161416843](操作系统.assets/image-20211112161416843.png)



**4.进程的组织**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670550229613)

- （1）链接方式

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670550432015)

- （2）索引方式

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670550610517)



**总结：**

![image-20211112162330656](操作系统.assets/image-20211112162330656.png)





#### 2.1.2 进程的状态及转换

**1.思维导图总览**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670551052819)



**2.进程的状态**

（1）三种基本状态（就绪、运行、阻塞）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670551324821)

（2）创建态和结束态

![在这里插入图片描述](操作系统.assets/20200312151550697.png)

* 创建态![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670551826424)
* 结束态
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670552025726)



**3.进程状态之间的转换**

* 进程一共有如下5种状态，那么他们之间如何实现切换呢？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670552252828)

* 咱们从一个进程的从无到有看起，来了解进程5种状态之间的转换

  > 运行态->阻塞态：进程自身的主动行为（不可逆）
  >
  > 阻塞态->就绪态：被动行为（不可逆）

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163670552435230)



#### 2.1.3 原语实现对进程的控制

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671529049952)



**1.什么是进程控制？**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671528795550)



**2.原语实现对进程的控制**

* 关于原语的作用和处在操作系统内核的重要地位可参考：[https://blog.csdn.net/weixin_43914604/article/details/104452762](https://blog.csdn.net/weixin_43914604/article/details/104452762)

  关中断期间不能被中断打断

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671528568348)

  



**3.回忆进程的组织**

* 进程在操作系统中的组织使各个进程能够有序的进行切换和运行
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671528305046)



**4.进程控制大致图解**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671527111342)
这里说明一下调度和切换的区别：

**调度**是指决定资源分配给哪个进程的行为，是一种决策行为；**切换**是指实际分配的行为，是执行行为，一般来说**先有资源调度，后有进程切换**



**5.进程控制原语的相同点**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671527414244)

* 接下来我们就具体学习一下关于进程控制的五种原语，

```
进程的创建、终止、唤醒、阻塞、切换；
```



**6.进程控制的五种原语**

（1）进程的创建原语

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671526877840)

（2）进程的撤销原语

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671526681938)

（3）进程的唤醒和阻塞原语

* 进程的**阻塞和唤醒原语是成对存在**的，必须成对使用

* 阻塞原语是由被阻塞进程自我调用实现的（主动）

* 唤醒原语是由一个被唤醒进程合作或被其他相关的进程调用实现的（被动）
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671526470036)

（4）进程的切换原语

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671526280434)



#### 2.1.4 进程之间的通信

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671612203662)



**1.什么是进程通信？**

* 图中我们可以知道什么是进程通信，以及进程通信的低级和高级方式；
* 我们还可以知道为什么要引入进程通信方式，以及它的意义
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671611757360)



**2.共享存储**

* 共享一块大家都可以访问的空间，一次**只能有一个进程进行读或写操作**
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671611519358)



**3.管道通信**

管道是一个特殊的共享区域

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671611022756)



**4.消息传递**

* 发送信息的进程将消息头写好，接受信息进程根据消息头读取信息或寻找信封是哪一个
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671610825454)



#### 2.1.5 线程概念与多线程模型

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671893825664)



**1.为什么要引入线程？**

线程成为程序执行流的最小单位

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671894095166)

* 为了方便于理解，我打开了我的任务管理器，可以看出chrome一个进程，下面有很多分支，可以把这些分支当做线程看待，PID即进程和线程都有的标识符。
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671894463268)



**2.什么是线程？**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671894816970)



**3.引入线程带来的变化及进程与线程的比较**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671895287972)



**4.线程的属性**

**线程**（英语：thread）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671895559574)



**5.线程的实现方式**

* 前面我们了解了引入线程的好处和引入线程的变化，以及线程的属性，那么线程如何实现呢？
* 线程的实现分为两类：**用户级线程(User-Level Thread,UTL)**和**内核级线程(Kernel-Level Thread, KTL)**。内核级线程又称内核支持的线程。

（1）用户级线程

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671895932076)

（2）内核级线程

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671896205978)

（3）特殊的组合方式及重点注意

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671896789780)



**6.多线程模型**

* 前面我们提到了线程的实现方式，有用户级和内核级。那么这两种模式的交叉组合就会产生几种不一样的组织结构，即不一样的模型。

（1）多对一模型

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671897936882)

（2）一对一模型

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671898189684)

（3）多对多模型

**此种模型效率是三种模型中最好的**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671898487086)



### 2.2 处理机的调度

#### 2.2.1 处理机调度的概念及层次

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671898978488)



**1.调度的基本概念**

> 按照一定算法选择进程将处理机分配给他

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671899194390)



**2.调度的三个层次**

（1）高级调度（ 作业调度）

> 外存->内存，建立PCB

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671904283292)

（2）中级调度（内存调度）

> 被挂起在外存的进程->内存（PCB常驻内存）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671904570394)

（3）进程的挂起状态与七状态模型

> 挂起（suspend）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671904787196)

（4）低级调度（进程调度）

> 就绪队列（内存）->分配处理机（CPU）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163671904994598)

（5）三层调度的联系和对比

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636719052016100)


#### 2.2.2 进程调度的时机、切换与过程、方式

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636720009600102)



**1.时机**

（1）什么时候进行进程调度？

> 当有处理机被放弃时（主动或者被动）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636720012216104)

（2）什么时候不能进行进程调度？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636720014319106)

（3）**OS内核程序临界区**与**普通临界区**的进程调度情况

> OS内核程序临界区例如就绪队列(由进程的PCB组成)是需要互斥访问的，而调度和切换也需要访问OS内核程序临界区，所以此时不能进行调度和切换

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636720016264108)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636720018607110)



**2.进程调度的方式**

* 所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636720021000112)



**3.进程的切换和过程**

> 进程调度 = 选择一个要运行的进程 + 进程切换

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636720023864114)



#### 2.2.3 调度算法的评价指标

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636721598925116)



**1.CPU利用率**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636721601422118)



**2.系统吞吐量**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636721603657120)



**3.周转时间**

> 从进程提交到进程完成的时间间隔为周转时间.也就是**等待进入内存的时间**,在就绪队列中等待的时间,在 CPU中执行的时间和I/O操作的时间的总和.
>
> 周转时间（一段时间） = 作业完成时间（一个时刻） - 作业提交时间（一个时刻）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636721605436122)![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636721607607124)



**4.等待时间**

> 进程等待时间：进程建立后->被服务
>
> 作业等待时间：作业在外存后备队列等待的时间+进程等待时间
>
> 调度算法只会影响等待时间

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636721610040126)



**5.响应时间**

![在这里插入图片描述](操作系统.assets/20200405160127509.png)



#### 2.2.4 作业/进程调度算法（早期的批处理系统）

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725120477129)



**1.先来先服务—FCFS**

* First come first server
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725122932131)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725128203133)



**2.短作业优先—SJF**

* Shortest Job First

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725130482135)

* 非抢占式—SJF
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725132643137)

* 抢占式—SJF(SRTN shortest remaining time next)

  > 平均等待时间和平均周转时间最小

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725134915139)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725137643141)

* 注意几个细节
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725140779143)



**3.高响应比优先—HRRN**

* Highest Response Ratio Next

  解决长作业饥饿的问题（一种动态的优先级调度算法）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725143979145)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725147909147)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725149740149)



4.三种算法的对比和总结

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636725152754151)



#### 2.2.5 作业/进程调度算法（交互式系统）

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790851759153)



**1.时间片轮转—RR**

处理机时间片（用于进程调度），适合分时系统（不能抢占，实时性不好）

* Round-Robin
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790853569155)

* 时间片为2举例
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790855442157)![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790861080159)

* 以时间片为5举例
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790866521161)

* 可能出现的问题，比如与FCFS对比

  > 时间片太大，退化为先来先服务算法，或者增大了响应时间
  >
  > 时间片太小，花费很大代价来进行调度和进程切换

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790868757163)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790870845165)



**2.优先级调度算法**

适合实时系统

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790872724167)

* 非抢占式例子
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790875552169)- 抢占式例子

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790877670171)

* 补充
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790880029173)



**3.多级反馈队列调度算法**

先来先服务 + 时间片轮转 + 优先级调度（抢占式）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790906685175)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790908837177)

* 举个例子
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790911029179)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790913461181)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790915740183)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790917996185)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790920437187)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790922780189)



**4.三种算法的对比总结**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636790927124191)



### 2.3 进程的同步与互斥

#### 2.3.1 进程的同步与互斥

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802379868193)



**1.进程同步**

* **同步也称为直接制约关系。**

  在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了**协调进程之间的相互制约关系,如等待、传递信息**等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。

* 一个简单的例子来理解这个概念。

  例如，让系统计算1 + 2x3，假设系统产生两个进程: 一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后,但实际上操作系统具有**异步性（各并发执行的程序以各自独立的、不可预知的速度向前推进）**,若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。

* **异步性：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。**



**2.进程互斥**

* 互斥，亦称间接制约关系。**进程互斥**指当一个进程访问某临界资源时，另一个想要访问该**临界资源**的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。

* 在这里需复习一下临界资源的概念。

  我们把**一个时间段内只允许一个进程使用的资源称为临界资源**。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。

  对临界资源的访问，必须互斥地进行。

  > 上锁--访问--解锁--其他处理

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802383700195)

* 为了禁止两个进程同时进入临界区，需遵循以下准则
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802389035197)



#### 2.3.2 实现临界区进程互斥的软件实现方法

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802392494199)

* 软件实现方法的思想：在**进入区设置并检查一些标志** 来标明是否有进程在临界区中,若已有进程在临界区，则**在进入区通过循环检查进行等待**，进程**离开临界区后则在退出区修改标志**。入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。



**1.单标志法**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802398683201)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751463935180)

**2.双标志先检查法**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802401877203)



**3，双标志后检查法**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802405398205)



**4.Peterson算法**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802408493207)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636802411708209)


#### 2.3.3 实现临界区进程互斥的硬件实现方法

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636807853585217)



**1.中断隐藏方法**

> 开关中断是对单个处理器的操作，所以在多处理机内，其他处理机也会访问临界区

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636807851248215)



**2.TestAndSet指令**

* 执行TSL指令时，它的内部运转逻辑：

  假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等

  假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将**上锁与检查在一个TSL指令完成**。

  > 同时会占用处理机一直进行上锁检查的操作，所以不满足“让权等待”的原则

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636807848609213)



**3.Swap指令**

* old是每个进程都要进行的一步，都必须将old=true

  分析一下这样做的原因：

  因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化old=true，然后进入while循环进行交换，如果**当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，同时因为交换，lock=old=true上锁，不让别的进程来打扰**，别的进程会因为lock变为true,一直在while循环等待,当我使用完临界资源，则将lock=false,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636807845211211)

> 先记录lock的值在old中
>
> 再上锁（lock = true）
>
> 最后检查old的值，false代表没有上锁可以访问临界区，出临界区再把lock设置为false
>
> TestAndSet是（old=lock，lock=true），Swap指令是（old=true，old<->lock）



#### 2.3.4 信号量机制

**0.思维导图**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636808150867219)



**1.为什么引入信号量机制？**

* 为了更好的**解决进程互斥与同步**的问题（检查和上锁一起完成）
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636808153431221-1636809592080245)



**2.什么是信号量机制？**

信号就是表示系统中某个资源数量的一个变量

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636808155549223-1636809589448244)



**3.整型信号量**

> 原子操作不允许中断，当原子操作无法完成时，会自动恢复到之前的状态
>
> 整形信号量还是没有解决让权等待的问题

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636808158983225-1636809587528243)



**4.记录型信号量**

> block原语在wait(P)原语中，可以使进程从运行态变为阻塞态，wakeup原语在signal(V)原语中，可以使进程从阻塞态变为就绪态

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636809581735241)

（1）举一个生动形象的例子了解记录型信号量

* 一张图咱们回忆一下进程的状态
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636809578263239)
* 一个例子
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636809575713237)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636809570902235)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636809566734233)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636809564600231)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636809562402229)

（2）梳理一下记录型信号量的知识点（P、V）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1636809559112227)



#### 2.3.5 信号量机制实现进程的互斥、同步与前驱关系

**0.思维导图**

* 在看此小结内容之前，需熟悉这一篇博客里面的知识，关于P、V操作内部实现原理等[https://blog.csdn.net/weixin_43914604/article/details/104951182](https://blog.csdn.net/weixin_43914604/article/details/104951182)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16368792006201)



**1.信号量机制实现进程互斥**

> semaphore(信号量)  mutex(互斥量，互斥锁)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16368792029643)



**2.信号量机制实现进程同步**

> 同步：各并发进程按要求有序地推进

* 想象一下四则运算的顺序，加减乘除；
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16368792054555)
* 要想理解这一部分知识，必须知道P、V操作的内部实现原理
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16368792075317)



**3.信号量机制实现前驱关系**

> 前驱关系就是多层的同步关系，为每一对前驱关系设置一个初始值为0的同步信号量

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16368792100119)



#### 2.3.6 进程同步与互斥经典问题

**0.前言**

* 同步时，前V后P。

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698461371011)



##### 1.生产者-消费者问题

（1）问题描述

* 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注: 这里的“产品”理解为某种数据)

* 生产者、消费者**共享**一个初始为空、大小为n的**缓冲区**。

* 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。

* 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。

* **缓冲区是临界资源，各进程必须互斥地访问**。

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698461590013)

（2）问题分析

* 1)关系分析。生产者和消费者对缓冲区互斥访问是**互斥关系**，同时生产者和消费者又是一个相互协作的关系，只有不为空时才能消费，只有不满时才能生产，它们也是**同步关系**。

* 2)整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
  生产者每次要消耗(P）一个空闲缓冲区，并生产(V)一个产品。
  消费者每次要消耗(P）一个产品，并释放一个空闲缓冲区(V)。
  往缓冲区放入/取走产品需要互斥。
* 3)信号量设置。设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。( 互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)

![在这里插入图片描述](操作系统.assets/20200326161730802.png)

（3）如何实现？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698461795615)

（4）**实现互斥的P操作一定要在实现同步的P操作之后**

> P(mutex)和V(mutex)之间为临界区，生产产品和消费产品可以放在临界区之外

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698462033217)

（5）知识回顾与重要考点

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698462246819)



##### 2.多生产者-多消费者问题

（1）问题描述

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698462428521)

（2）问题分析

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698462638023)

（3）实现方法

① 有mutex

> 同步信号量plate初值为1

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698462832625)

② 无mutex

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698463030027)

③ 为什么有mutex和没有mutex一样呢？

* 原因在于:本题中的**缓冲区大小为1，在任何时刻，apple、 orange、 plate 三个同步信号量中最多只有一个是1，而四个进程在刚开始会对三者其中一个进行P操作。因此在任何时刻，最多只有一个进程的P操作不会被阻塞**，并顺利地进入临界区…

④ 如果有两个盘子plate

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698463293229)

（4）知识总结与重要考点

* 总结:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。**当缓存区大于1，必须设置互斥信号量**

* 建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“**死锁**”。

> **分析同步问题时，不能从单个进程来看，要从一个事件的角度来看**，一个事件发生在另一个事件之前

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698463674131)





##### 3.读者-写者问题

（1）问题描述

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698463878033)

（2）问题分析

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698464114835)

（3）实现方法

① 给count加mutex互斥访问

* 这里说一下为什么要加mutex。
* 比如：当count=0时，第一个读者进程执行到p(rw),rw=0,假设此时时间片到了，切换到第二个读者进程,第二个进程发现count=0,则执行p(rw)，但是此时rw=0，于是第二个进程被堵在p（rw）这里，同理，后面的可能会有多个进程堵在p(rw)，只有当第一个进程再次获得时间片，执行count++,让count不为0，然后其他进程就可以直接绕过if直接进行count++来访问文件，但是第三个读者进程和后面的几个可能堵在p(rw)的多个读者进程则必须得等count–为0后才可以再次和写进程竞争来访问文件，对count的访问没有做到一气呵成，会导致本来一些进程一直堵在p（rw）。
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698464326837)

② 加一个w实现“读写公平法”

* 在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有 一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在**写进程“饿死”**的情况。

* 若希望**写进程优先**，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并在上面程序的writer()和 reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。

  > 写者和写者互斥，写者和读者互斥，读者和读者不互斥，写进程优先（不被饿死，第一次被阻塞后被唤醒的优先级最高）
  >
  > 第一个读进程给文件加锁，最后一个读进程才给文件解锁（int count以及对count的互斥信号量）

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698464597239)

（4）知识回顾与重要考点

![ ](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698464846041)



##### 4.吸烟者问题

（1）问题描述

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698465019643)

（2）问题分析

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698465175745)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698465404547)

（3）实现方法

> 缓冲区大小为1，在某一个时刻，**四个同步信号量中最多一个值为1**，**只会有一个进程不被P操作阻塞**，所以不需要互斥信号量

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698465606149)

（4）知识回顾与重要考点

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698465862051)



##### 5.哲学家进餐问题

（1）问题描述

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698466038853)

（2）问题分析

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698466258055)

（3）如何实现

> 第一种解决方案，同时最多允许四个哲学家进餐，设置一个初始值为4的同步信号量
>
> 第二种解决方案，奇数号哲学家先拿左边筷子，再拿右边筷子，偶数相反，在程序中做一个if判断即可
>
> 第三种解决方案，哲学家拿起左右筷子需要一气呵成，设置一个初始值为1的互斥信号量mutex

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698466524457)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698466762059)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698466941261)

（4）知识回顾与重要考点

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698467162063)



#### 2.3.7 管程和java中实现管程的机制

[]()0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698467360465)

1.为什么引入管程？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698467550967)



2.管程的组成及基本特征

> 管程当作类class，**共享数据结构**为类的属性，**一组过程**为类的方法
>
> 每次只允许一个进程在管程内执行某个内部过程

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698467948469)



3.管程实现生产者消费者问题

> monitor 和 end monitor 定义管程
>
> condition**条件变量配合wait()和signal()来实现进程同步（等待和唤醒操作）**，此处是**直接等待和唤醒**，而不是类似PV操作对信号量+1-1操作再进行阻塞，所以要自己加 if 或者 while 判断
>
> 互斥信号量定义为普通变量，由**编译器负责实现各进程互斥地进入管程中的过程**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698468180571)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698468401273)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698468614975)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698468842077)



4.java中类似于管程的机制

> Java中关键字synchronize描述一个函数，此函数在同一时刻只能被一个线程调用

![1](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163698469076479)



### 2.4 死锁

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704265923293)

##### 2.4.1 死锁的概念

1.什么是死锁？

> 在并发环境中，各进程因竞争资源而造成各进程阻塞，都无法向前推进

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704265775991)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704265600789)



2.死锁、饥饿、死循环的区别

> 死锁和饥饿不在运行态，死循环在运行态，死锁和饥饿是操作系统应该解决的问题

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704265389787)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704264820785)



3.死锁产生的四个必要条件

> 互斥条件
>
> 不剥夺条件
>
> 请求和保持：保持一个资源不放被阻塞
>
> 循环等待条件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704264576083)



4.什么时候会发生死锁？

> 对不可剥夺资源的不合理分配
>
> 实现互斥的P操作在实现同步的P操作之前，导致死锁，是因为互斥P操作被阻塞后，同步操作无法执行

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704264369681)



##### 2.4.2 死锁的处理策略

![image-20211116140356258](操作系统.assets/image-20211116140356258.png)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751478079183)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163767675299631)

1.预防死锁

① 破坏互斥条件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704920601095)

② 破坏不可剥夺条件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704920849797)

③ 破坏请求和保持条件

> 静态分配方法：进程在运行前申请完它需要的所有资源，不然不投入运行，容易导致饥饿

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163704921078499)

④ 破坏循环等待条件

> 顺序资源分配法：如一个进程只有已经占用小编号的资源时，才能申请大编号资源，不能逆向申请，不会产生循环等待的现象

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049218561101)



2.避免死锁

① 什么是安全序列？

* 所谓安全序列
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049220978103)
  
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049223272105)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049225962107)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049228737109)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049232200111)

② 安全序列、安全状态、不安全状态、死锁之间的联系

> 安全序列：系统按照这种序列分配资源，每个进程都能顺利完成
>
> 安全状态：系统有一到多个安全序列，一定不会发生死锁
>
> 不安全状态：系统中找不到安全序列，有可能发生死锁
>
> 在分配资源前判断这次分配是否导致系统进入不安全状态

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049240328113)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049243930115)

③ 避免系统进入不安全状态------银行家算法

- 有安全序列的例子

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049246488117)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049248961119)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049257305121)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049260281123)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049265849125)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049268913127)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049271569129)

- 找不到安全序列的例子

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049274449131)

* 使用代码实现

  > Max矩阵代表各进程的最大需求，Allocation矩阵代表各进程已分配的资源数，Need矩阵为二者差值
  >
  > 1.检查该线程的此次申请是否超过了其声明的最大需求，超过报错
  >
  > 2.检查系统所剩资源能否满足此次需求
  >
  > 3.尝试分配资源，改变数据结构
  >
  > 4.用安全性算法检查此次分配是否会导致系统进入不安全状态，安全性算法不通过会导致该线程阻塞
  >
  > 安全性算法：（**相当于模拟一遍所有线程的运行及资源分配过程**）检查当前的剩余资源能否满足其他某个进程的最大需求，如果可以，把该进程加入安全序列，并把该进程持有的所有资源回收，重复上述过程，看能否将所有进程都加入安全进程。

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049278665133)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049282033135)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049331025137)



3.死锁的检测和解除

![在这里插入图片描述](操作系统.assets/20200410213835909.png)

① 死锁的检测

> 图的数据结构
>
> 检测死锁算法：（当进程的请求边小于等于被请求资源的数量）进程执行完毕后归还资源给系统，消除分配边和请求边。
>
> 如果最终可以消除所有边，图可以完全简化，此时没有发生死锁。
>
> 如果不能消除所有边，发生死锁。

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049336706140)

* 举个例子，可以消除所有边，即无死锁发生
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049339977142)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049342993144)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049346066146)
* 举个例子，不可消除所有边，即产生死锁
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049348777148)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049351521150)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049354081152)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049356841154)

② 死锁的解除

> 优先牺牲批处理式的，用户对交互式的进程更加敏感

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637049359881156)



## 第 3 章 内存管理

### 3.1 内存管理的概念

#### 3.1.1 进程的基本原理

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068474351196)



1.什么是内存？有何作用？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068472575194)

（1）存储单元

* 关于存储单元有关内容在我写的组成原理笔记中有提到：[存储单元](https://blog.csdn.net/weixin_43914604/article/details/104099953)、

  > 64位系统CPU数据宽度为64位，指令集为64位

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068470551192)

（2）几个常用数量单位&内存地址

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068468376190)

2.进程运行的基本原理

（1）**指令的工作原理—操作码+若干参数（可能包含地址参数）**

* 从X=X+1大致看一下指令的执行过程

  > 进程包括程序段、数据段和PCB

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068465799188)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068463663186)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068461472184)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068459384182)

（2）逻辑地址（相对地址）vs物理地址（绝对地址）

> 指令中对变量使用相对地址，实际放入内存再确定绝对地址

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068457120180)（3)从写程序到程序运行—**编译、链接、装入**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068454879178)

（4）装入模块装入内存

**不修改装入模块中的指令地址就直接装入内存的话：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068452889176)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068451193174)

（5）装入的三种方式

> **装入可以完成逻辑地址到物理地址的转换**

①绝对装入：在编译时就知道程序会放在内存中的位置

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068448889172)

②静态重定位（可重定位装入）：在装入时对地址进行重定位

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068446784170)

③ **动态重定位（动态运行时装入）：在程序要执行的时候才进行重定位，允许程序在运行时移动，程序可被分配到不连续的存储区，装入部分代码即可运行**（**一般采用的方式**）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068444543168)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068442376166)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068440154164)

（6）链接的三种方式

① 静态链接：装入内存前链接好

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068438216162)

②装入时动态链接：一边装入内存一边链接

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068435945160)

③**运行时动态链接：程序运行时再进行链接**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637068434129158)



#### 3.1.2 内存管理

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134436488198)

1.**内存空间的分配与回收**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134438613200)



2.内存空间的扩展（实现虚拟性）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134441190202)



3.地址转换（装入）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134443485204)

**三种方式**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134447885206)



4.内存保护

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134450557208)

**两种方式**

> 上下限寄存器
>
> 基址+限长寄存器

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134455158210)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134457133212)



#### 3.1.3 覆盖技术与交换技术

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134459854214)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134462460216)

1.覆盖技术

> 将程序分为多个段，内存分为固定区和覆盖区，**必须由程序员声明覆盖结构**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134464757218)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134468764220)



2.交换技术

> **进程在内存和外存之间动态调度**，**中级调度（内存调度）就是为了实现交换技术的一种策略**，**新增就绪挂起和阻塞挂起两个状态**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134471797222)

* 回忆复习一下进程调度
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134474093224)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134476725226)



#### 3.1.4 内存的分配与回收

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134479758228)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134482060230)

>外部碎片是位于任何两个**操作系统分配的用于装载进程的内存区域**或页面之间的空闲区域，内部碎片是位于一个**操作系统分配的用于装载进程的内存区域**或页面内部的空闲区域

> **连续分配：为一个进程分配的必须是一个连续的内存空间**

1.单一连续分配

> 早期的单道程序系统

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134485181232)



2.固定分区分配

> 多道程序系统，分区大小相等**适合用一台计算机控制多个相同对象的场合**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134488012234)

分区说明表

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134490541236)



3.动态分区分配（可变分区分配）

> 不会预先划分内存分区，而是在进程装入内存时，根据进程大小动态地建立分区

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134493061238)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134495421240)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134497661242)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134499869244)

（1）系统要用怎样的数据结构记录内存的使用情况呢？

> 空闲分区表和空闲分区链

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134502173246)

（2）当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134504510248)

（3）如何进行分区的分配和回收操作？

**如何分配？**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134506869250)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134509023252)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134511438254)
**如何回收？**

> 将相邻的空闲区域合并

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134513958256)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134516012258)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134518066260)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134520086262)



4.内部碎片与外部碎片

> 内部碎片：分配给某进程的内存区域，但是没用上，动态分区分配不会有内部碎片
>
> 外部碎片：内存中的某些区域太小未被分配出去（通过紧凑技术解决）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134522517264)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134524845266)



#### 3.1.5 动态分区分配的四种算法

0.思维导图

* 本篇文章是对上一篇文章内存的分配与回收提到的**动态分区分配算法的补充**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134527357268)



1.首次适应算法

> 空闲分区**按照地址递增次序排序**，从低地址查找，找到第一个满足要求的空闲分区

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134532413270)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134534576272)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134536573274)



2.最佳适应算法

> 空闲分区**按照容量递增次序排列**，从低容量查找，找到第一个满足要求的空闲分区

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134538856276)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134541261278)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134543197280)



3.最坏（大）适应算法

> 优先使用最大的连续空闲区，减少外部碎片的产生

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134545533282)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134547461284)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134549589286)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134551725288)



4.临近适应算法

> 与首次适应算法相似，每次从上次查找结束的位置开始检索，缺点是导致高地址大分区容易被使用

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134554310290)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134556485292)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134558783294)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134560791296)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134562981298)



5.四种算法归纳比较

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134565510300)



#### 3.1.6 分页存储

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637134567629302)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137485733328)



1.为什么学习分页存储？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137483822326)



2.基本分页存储管理的思想

> 将内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137481655324)



3.分页存储管理的重要概念

> 内存空间：页框或者页帧或者内存块
>
> 用户进程地址空间：页或者页面

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137479566322)



4.如何实现地址的转换

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137477559320)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137475423318)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137473325316)

> **实际物理地址 = 页面始址 + 页内偏移量**
>
> 页内偏移量 = 逻辑地址 % 页面长度
>
> 页号 = 逻辑地址 / 页面长度
>
> 页面始址由操作系统用某种数据结构记录
>
> （基本分页存储中内存分页和进程内存空间分页大小相同）

**如何计算页号和页偏移量**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137470958314)
**为什么页面大小一般设为2的整数次幂？**（方便计算页号和页内偏移量）
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137469198312)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137466255310)

**分页存储的逻辑结构**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137464174308)

**如何知道页面在内存中的起始地址？**

* 这里引入一个新的概念：**页表**（一个进程有一张页表，在内存中，是连续的）

  > 页表记录页号（隐含的）和实际存放的内存块号（M号内存块的起始地址就是M*内存块大小）之间的对应关系

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137462223306)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137459943304)



#### 3.1.7 分页存储管理的基本地址变换结构

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137940299330)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137943197332)



1.页表寄存器 Page-Table Register

> **页表长度M是指页表的个数，页号P < 页表长度M**
>
> **页表项长度是存放内存块地址的存储空间（如3个字节24位）**
>
> **页面大小才是指一个页面占多大的存储空间**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137947391334)

> 页表起始地址（页表是连续的）和页表长度刚开始被放在PCB中，当进程被调度时，被放到页表寄存器PTR

**地址变换过程**

> 1.根据逻辑地址计算页号和页内偏移量
>
> 2.根据页表长度和页号判断是否越界
>
> 3.查询页表（隐含页号），得到内存块号（第一次访问内存）
>
> 4.根据内存块号和页内偏移量得到物理地址
>
> 5.范围目标内存单元**（第二次访问内存）**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137949418336)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137951367338)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137954395340)
**一道例题加深印象：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137956967342)



2.对页表项大小的进一步讨论

> 页表项长度和内存块号的范围相关，隐含了页号，比如页表项占3个字节，页表第0到3个字节就表示了第0个内存块的起始地址

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637137959196344)


#### 3.1.8 分页存储管理的快表的地址变换结构

0.思维导图

* 上一篇文章学习了[分页存储管理的基本地址变换结构](https://blog.csdn.net/weixin_43914604/article/details/105909842),这一篇文章是对基本地址变换结构的改进版。
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149094650346)



1.局部性原理引入快表机制

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149096834348)



2.快表（TLB）

Translation Look-aside Buffer

TLB中文全称：地址变换高速缓存

TLB中文简称：快表

TLB实际性质：它是一种cache

![在这里插入图片描述](操作系统.assets/20200505111455765.png)

**一个例图了解基于快表的地址变换结构**

> 访问过的页表项会被存入快表(页号和内存块号对应表)，相当于一种缓存机制
>
> **快表命中，不需要检查页号合法性，不需要查页表，但访问目标内存单元也相当于访问一次内存**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149103233351)
**引入快表后，地址变换的过程的文字描述：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149105720353)



3.基本地址变换与快表地址变换的比较

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149108114355)



#### 3.1.9 二级页表的原理和地址结构

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149110784357)



1.为什么引入二级页表？

> 页表在内存中也是按照内存块放置

**因为单级页表存在一些问题，所以引入二级页表和多级页表，有两个问题：**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149113099359)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149115169361)
**上面提到了这两个问题，那么总结一下，并提出解决思想，引入二级页表的概念。**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149117657363)



2.二级页表的原理和地址结构

> 页表在内存中也是按照内存块放置，若页表占据了多个内存块，可以让这些内存块离散，再为页表建一个目录（页目录表），此页表放在PCB中，进程被执行时被放入页表寄存器PTR
>
> 各级页表大小不超过一个页面大小（内存块大小）

* 对页表再次分组
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149119881365)
* 二级页表的地址结构及对应关系
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149122352367)



3.如何实现二级页表的地址变换？

> 1.从PCB（或者页表寄存器PTR）中读取页目录表始址（连续的），根据一级页号查到下一级页表的内存块号
>
> 2.二级页号相当于偏移量，找到最终要访问的内存块号
>
> 3.通过页内偏移量得到最终的物理地址

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149128266369)
**上面的部分我们解决了问题一，接下来是问题二，这里简单叙述一下，后面的文章会继续深入剖析。**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149130744371)



4.几个小细节

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637149132897373)


#### 3.1.10 基本分段存储管理

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154458315375)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154460201377)



1.什么是分段？

> 按自身的逻辑关系分段，不是固定长度的页

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154462835379)

**分段的逻辑地址结构**

> 段号 + 段内地址（段内偏移量）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154465017381)



2.段表

> **段表相较于页表多个段长这个数据，段表项长度是相同的，段号和页号一样是隐含的**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154467249383)



3.地址变换

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154469568385)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154471984387)



4.分段、分页管理的对比

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154473808389)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751485870185)

**分段实现信息共享共享**

> 不能修改的代码不属于临界资源，才能被共享

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154476800391)

**为什么分页不方便实现信息共享和保护？**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154479192393)


#### 3.1.11 段页式存储管理

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154481736395)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154484216397)



1.分页、分段的优缺点分析

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154486081399)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154487882401)



2.分段+分页=段页式管理

> **先分段，再对段分页**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154489897403)

**段页式管理的逻辑地址结构**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154491752405)

**段页式存储的段表、页表**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154493617407)



3.段页式管理的地址转换过程

> 段表、页表和目标内存单元

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154495920409)



### 3.2 虚拟内存管理

#### 3.2.1 虚拟内存的基本概念

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154502978411)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154505114413)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154507049415)



1.传统存储管理的特征、缺点

> 一次性和驻留性

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154508962417)



2.局部性原理

> 寄存器  高速缓存  内存  外存

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154511440419)



3.虚拟内存的定义和特征

> 基于局部性原理，很快用到的部分会装入内存，暂时用不到的留在外存
>
> **虚拟内存和交换技术的区别：**
>
> 交换技术是在不同的进程（作业）间的，以进程为单位，属于中级调度/内存调度
>
> 虚拟内存是在一个作业间的，以段或者页为单位

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154516729421)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154519304423)



4.如何实现虚拟内存技术

> **请求调页和页面置换**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637154521713425)



#### 3.2.2 请求分页管理方式

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374097154481)



1.知识总览

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374097232803)



2.页表机制—请求页表与基本页表的区别

> 增加四个字段状态位（是否调入内存）、访问字段（被访问次数或者最近时间）、修改位（调入内存后是否被修改）、外存地址

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374097256655)



3.缺页中断机构

> 要访问的页面不在内存时，产生缺页中断，进程被阻塞，调页完成后被唤醒

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374097290067)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374097379159)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740973989511)

> 缺页进程重新进入就绪态时，内存有空闲块，将所缺页面装入
>
> 内存无空闲块，由置换算法淘汰一个页面，如果页面被修改过需要放回内存

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740974714313)

**缺页中断**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740974938415)



4.地址变换机构

> 新增1：如果缺页，需要请求调页（会直接加入快表）
>
> 新增2：如果内存空间不够，需要页面置换（会直接加入快表）
>
> 新增3：修改请求页表中的一些字段

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740975233417)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740975473519)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740975746421)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740976031223)

 

#### 3.2.3 页面置换算法

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740976335925)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740976544927)



1.最佳置换算法—OPT

> optimal replacement，不可实现，性能最好，用于评价其他算法性能

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740976835829)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740977051031)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740977366433)



2.先进先出置换算法—FIFO

> Belady异常，当为进程分配的物理块数增大时，缺页次数不减反增

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740977760735)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740978034337)



**3.最近最久未使用置换算法—LRU**

> java如何实现？哈希表+双向链表

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740978297739)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740978553441)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740979009643)



4.时钟置换算法(最近未使用算法)—CLOCK

> 所有页面链接成一个循环队列，按扫描顺序淘汰，最多扫描两轮
>
> （访问位）表示状态
>
> 第一轮扫描（0）进行替换，同时将（1）改为（0）（未被访问的）
>
> 第一轮失败，第二轮扫描（0）进行替换（已被访问的）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740979302245)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740979568747)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740979836849)



5.改造型时钟置换算法

> 在最近未使用算法的基础上，考虑优先淘汰在内存中但是未被修改的页面
>
> (访问位，修改位)表示状态
>
> 第一轮扫描（0,0）进行置换（未被访问未被修改的）
>
> 第一轮失败，第二轮扫描（0,1）进行置换，同时将所有访问位改为0（未被访问已被修改的）
>
> 第二轮失败，第三轮扫描（0,0）进行置换（已被访问未被修改的）
>
> 第三轮失败，第四轮扫描（0,1）进行置换（已被访问已被修改的）
>
> 

**只需一轮：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740980167251)
**需要两轮：** ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740980400753)
**需要三轮：** ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740980652655)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740980944257)
**需要四轮：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740981186959)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740981486261)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740981764963)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740982095965)



6.各算法优缺点

![image-20211117215930924](操作系统.assets/image-20211117215930924.png)



#### 3.2.4 页面分配策略

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740982754267)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740982955169)



1.驻留集—给进程分配的物理块的集合

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740983492871)



2.页面分配、置换策略

![  ](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740983722473)

**固定分配局部置换、可变分配局部置换、可变分配全局置换**

> 可变分配全局置换：只要缺页就分配新的物理块
>
> 可变分配局部置换：根据缺页的频率来动态分配进程的物理块

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740983973475)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740984540679)



3.何时调入页面？

> 预调页（空间局部性）：运行前调入
>
> 请求调页：缺页时调入（运行时调入）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740984329577)



4.从何处调页？

外存分为对换区（读写速度快）和文件区（读写速度慢）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740985067981)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740985324783)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740985599185)



5.抖动（颠簸）现象

> 刚刚换入又要换出，刚刚换出又要换入，原因是分配给进程的物理块空间不够

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740985894687)



6.工作集

驻留集不能小于工作集

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163740986152789)



## 第 4 章 文件管理

### 4.1 文件系统

#### 4.1.1 文件管理概念和功能

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374603652571)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374603678313)



1.文件的属性

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374603700545)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374603722297)

> 标识符是操作系统区分文件的内部名称



2.文件内部的数据如何组织起来？

> 无结构文件--流式文件
>
> 有结构文件--记录式文件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16374603744439)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746037713211)



3.文件之间应该如何组织起来？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746037937913)



4.操作系统应该向上提供哪些功能？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746038192115)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746038426817)



5.从上往下看，文件应该如何存放在外存？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746038654319)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746038905221)



6.其他需要由操作系统实现的文件管理功能

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746039118923)



#### 4.1.2 文件逻辑结构

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746220375125)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746220590827)



1.无结构文件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746220828429)



2.有结构文件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746221015731)
**定长记录：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746221250133)
**不定长记录：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746221864235)

**有结构文件的逻辑结构**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746222086037)

- 顺序文件

  > 采用顺序存储（物理上顺序排列）、定长记录可以**实现随机存取**加上顺序结构（记录之间按关键字顺序排序）可以快速找到某个关键字对应的记录，缺点是增删比较麻烦

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746222356539)
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746222590041)

- 索引文件

  > 使用索引表（每条记录对应一个索引），有很快的检索速度
  >
  > 索引表自身也是一个顺序文件

  不经意间让我想起了数据库的索引，聚簇索引和唯一索引等，有了更进一步的理解，而且知道了它的时间空间效率。
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746222810043)

- 索引顺序文件

  > 并不是每个记录而是一组记录对应一个索引表项，每个分组就是一个顺序文件

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746223022045)
  **索引顺序文件的效率分析：**
  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746223248647)

  **多级索引顺序文件**

  > 多级索引表 + 顺序文件

  ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163746223726349)



#### 4.1.3 文件目录结构

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16375827040341)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16375827061453)



1.文件控制块FCB file control block

> 目录文件是一种有结构文件，有多个文件控制块FCB组成

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16375827084315)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16375827107277)

**对目录的操作**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16375827127629)



2.单级目录结构

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758271494211)



3.两级目录结构

> 主文件目录和用户文件目录

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758271700313)



4.多级目录结构(树形目录结构)

> 从根目录出发：绝对路径
>
> 从当前目录出发：相对路径（减小磁盘IO次数）
>
> 便于文件管理和保护，不便于文件共享

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758272192715)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758272414417)
**无环图目录结构解决文件共享**

> 可以用不同的文件名指向同一个文件，有向无环图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758272707919)



5.无环图目录结构

> 共享结点设置共享计数器，删除时共享计数器 -1，共享计数器为0时才真正删除文件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758273310421)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758273631223)



6.索引节点(对FCB的改进)瘦身

> 查找文件时，只需要用到文件名这个信息，可以对文件控制块进行瘦身，将其他信息放到索引结点，FCB中再添加一个索引结点指针，**增加磁盘访问速度**
>
> **文件检索速度——当FCB过大，每个磁盘块只能放较少的FCB，同样多的目录项，需要访问多个磁盘块才能确定FCB的位置**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758274209525)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758274510427)



#### 4.1.4 文件的物理结构

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758352114329)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751490909187)



1.文件块、磁盘块（物理块）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758352407831)

> 类似页号和页内地址，由**逻辑块号和块内地址转化为物理块号和块内地址**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758352635233)



2.连续分配

物理块在内存中连续

**连续分配优点：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758352887335)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758353119137)
**连续分配缺点：**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758353382239)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758353675041)
![在这里插入图片描述](操作系统.assets/20200526122009923.png)



3.链接分配

![在这里插入图片描述](操作系统.assets/20200526122103375.png)

**隐式链接**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758353950243)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758354227545)

**显式链接**

一个磁盘只设置一张文件分配表（物理块号和下一块号的对应关系）（FAT file allocation table）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758354461547)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758362000649)

**链接分配总结**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758362226151)



4.索引分配

> 每个文件都有一张索引表

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758362433353)
**如何实现逻辑块号到物理块号的转换？**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758362650855)
**数据太大，一个索引表装不下那么多的映射怎么办？**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758362842157)

**链接方案**

> 多个索引块链接起来

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758363051759)

**多层索引**

> 类似多级页表

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758363295661)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758363506263)

**混合索引**

> 直接地址索引+一级间接索引+两级间接索引
>
> 小文件可以用较少的读盘次数就可以访问目标数据块

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758363733365)

**索引分配总结**

> FCB中会有指向顶级索引块的指针，要判断FCB是否已经调入内存

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758365143769)



5.文件物理结构分配总结

**顺序访问**：链表在内存中不是按顺序存放的，而是通过指针连在一起，为了访问某一元素，必须从链头开始顺着指针才能找到某一个元素。
**随机访问：**数组在内存中是按顺序存放的，可以通过下标直接定位到某一个元素存放的位置。

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758364731767)



#### 4.1.5 文件管理空闲磁盘块的几种算法

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758390804971)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758392677973)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758393107575)



1.存储空间的划分与初始化

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758393476977)



2.空闲表法

**如何分配？**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758394798379)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758395024781)
**如何回收？**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758395251583)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758395466285)



3.空闲链表法

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758395699887)

**空闲盘块链**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758396172889)

**空闲盘区链**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758396386891)



4.位示图法

> 盘块号  和  字号位号的对应关系

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758396875793)
**如何分配与回收？**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758397125195)



5.成组链接法

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758397450697)
**超级块的作用**

> 超级块中的第一个盘块又指向下一个分组，当超级块的空闲区域被分配出去，第一个盘块的信息更新给超级块，超级块的内容刷新，重新指向新的空闲块组

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163758397671699)
**如何分配？**
**需要1个空闲磁盘块**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637583981691101)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637583983844103)
**需要100个空闲磁盘块**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637583985733105)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637583987470107)
**如何回收？**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637583989741109)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637583992614111)
**第二种情况，第一组已满**

> 新回收的块成为超级块的第一个分组

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637583994580113)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637583996485115)

#### 4.1.6 文件的基本操作原理

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751517247191)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751553900205)



1.创建文件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751521445193)



2.删除文件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751525292195)



3.打开文件

> 内存中的打开文件表（进程和系统的），不需要每次重新查目录
>
> 打开文件表序号——文件描述符

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751528660197)
**打开文件表有两种：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751530988199)



4.关闭文件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751533900201)



5.读文件

> 外存到内存

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751536645203)





6.写文件

> 内存到外存



![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586251686117)


#### 4.1.7 文件共享

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586758976119)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586761563121)



1.基于索引结点的共享方式（硬链接）

> 不同用户的目录项指向同一个索引结点，**无环图目录结构**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586764304123)



2.基于符号链的共享方式（软链接）

> link类型文件（类似快捷方式）,用户目录项指向link类型文件，link类型文件指向其他用户的文件目录项

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586766322125)
**例子**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586768477127)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586770814129)

**共享的文件不存在时**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586772862131)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586775032133)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637586777154135)


#### 4.1.8 文件保护

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587280864137)



1.口令保护

> 口令在FCB或者索引结点中

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587285143139)



2.加密保护

> 文件数据加密算法

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587287500141)



3.访问控制

> 每个文件的访问控制表（对用户权限的限制）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587289764143)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587292125145)



#### 4.1.9 文件系统的层次结构

0.知识总览

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587570979147)



1.举个例子

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587573410149)



### 4.2 磁盘组织与管理

#### 4.2.1 磁盘的结构

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587677452151)



1.磁盘、磁道、扇区

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587679864153)



2.如何在磁盘中读/写数据

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587682393155)



3.盘面、柱面（指的是不同磁道）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587684482157)



4.磁盘的分类

按磁头是否可移动分类

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587687159159)

按盘片是否可更换分类

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637587689507161)


#### 4.2.2 磁盘调度算法

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16376698519141)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16376698541913)



1.一次磁盘读/写操作需要的时间

> 寻道时间影响最大  +  延迟时间  +  传输时间

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588644848167)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588642715165)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588640813163)



2.先来先服务(FCFS)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588654722169)



3.最短寻找时间优先算法（SSTF）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588662995171)



4.扫描算法（SCAN）

> 电梯算法，只有到了最边上的磁道才能改变磁头移动方向

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588670894173)



5.LOOK算法

> 对扫描算法的改进，在移动方向上没有别的请求就可以改变磁头方向

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588715574175)



6.循环扫描算法（S-SCAN）

> 只有一个扫描方向（比如从左到右，右到左快速返回），对各个位置磁道的响应频率均匀

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588717984177)



7.C-LOOK算法

>只有一个扫描方向（比如从左到右，右到左快速返回），返回条件是在移动方向上没有别的请求

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637588720160179)


#### 4.2.3 减少磁盘延迟时间的方法

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16376698724345)



1.前情回顾

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16376698745687)



2.交替编号

> 逻辑上相邻扇区在物理上间隔可以减小延迟时间

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16376698768859)



3.磁盘地址结构的设计

> (柱面号，盘面号，扇区号)，柱面号的切换需要切换磁道，盘面号切换是激活不同的磁通，扇区号是磁盘的旋转

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766987952111)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766988228013)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766988455315)



4.错位命名

> **同一个盘面的扇区应该交替命名，不同盘面的扇区号应该错位**，如（0,0,7）到（0,1,0）减小延迟时间

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766988736717)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766988965519)



#### 4.2.4 磁盘管理

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766989185521)



1.磁盘初始化

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766989443923)



2.引导块

> ROM中只有只举装入程序，初始化程序（引导块）放在c盘

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766989665625)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766990220627)



3.坏块的管理

> 逻辑格式化时标明坏块

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163766990496029)



## 第 5 章 I/O管理

### 5.1 I/O管理概述

#### 5.1.1 I/O设备

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16377511911911)



1.什么是I/O设备？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16377511945183)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16377511973045)



2.I/O设备的分类

（1）按使用特性分类

> 交互设备，存储设备，网络设备

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16377512000057)

（2）按传输速率分类

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16377512025659)

（3）按信息交换单位分类

> 块设备（可寻址），如磁盘
>
> 字符设备（中断驱动方式），如鼠标

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775120522111)


#### 5.1.2 I/O控制器

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775120787813)



1.I/O设备的组成

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775121018115)

（1）机械部件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775121234817)

（2）电子部件—I/O控制器的功能

> CPU控制IO控制器，IO控制器控制机械部件
>
> 控制寄存器，状态寄存器，数据寄存器

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775121477219)



2.I/O控制器的组成（可以对应多个设备）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775121753321)
**注意：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775122002823)



3.I/O控制器的两种寄存器编址方式

> 内存映像：和内存地址统一编址
>
> 独立编址：

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775122234925)


#### 5.1.3 控制I/O设备的方式

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775122531627)



1.程序直接控制方式

**key word : 轮询检查IO状态，忙等**

* 完成一次读/写操作的流程图(以读操作为例)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775122905629)
**下面以C语言代码和流程图来剖析，程序直接控制方式**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775123115031)
**分析一下在思维导图中提到的几个问题：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775123326033)



2.中断驱动方式

* 由于程序直接控制方式CPU利用率低，忙等，所以提出了中断驱动方式。

> 把等待IO进程阻塞，切换到其他进程，IO响应后给CPU一个中断信号

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775123598135)
**分析一下在思维导图中提到的几个问题：**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775123884437)



3.DMA方式

* 虽然**中断驱动方式**解决了程序直接控制方式的问题，但是**每一次只能读/写一个字**，导致CPU频繁切换，耗费了很多时间。于是人们又发明了DMA方式。

> 传送单位是块，由设备直接到内存或者内存到设备，不再经过CPU，CPU只在开始或者结束时才进行干预

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775124170039)
**DMA控制器：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775124403041)
**分析一下在思维导图中提到的几个问题：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775124668543)



4.通道控制方式

* **通道控制方式是为了解决DMA方式连续存储的问题**

> 通道：相当于一种低配版的CPU，可以设别通道指令，每次存取一组块（可以是离散的）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775124936945)
**分析一下在思维导图中提到的几个问题：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775125206247)



5.四种方式总结一下

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775125441349)


#### 5.1.4 I/O软件的层次结构

0.I/O软件层次总览

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775125640651)



1.用户层软件

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775125882053)



2.设备独立性软件

> 与系统硬件无关的功能
>
> 1.向上层提供接口
>
> 2.设备保护
>
> 3.差错处理
>
> 4.设备的分配与回收
>
> 5.数据缓冲区管理
>
> 6.逻辑设备名和物理设备名对应/设备驱动的调用

六大功能

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775126118955)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775126382057)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775126658259)

[]()逻辑设备表—LUT

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775127103761)

[]()为什么不同的设备需要不同的驱动程序呢？

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775127314263)
**举几个假设的例子：**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775127587665)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775127812467)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775128038469)



3.设备驱动程序

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775128260471)



4.中断处理程序

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775128475673)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775128713475)



5.总结回顾

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775128944477)



### 5.2 I/O核心子系统

#### 5.2.1 内核的I/O核心子系统及功能

0.I/O核心子系统以及功能

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775129191079)



1.这些功能在哪个层次实现？

**假脱机技术（SPOOLing）**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775129435681)

**I/O调度**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775129728683)

**设备保护**

> 设备是一种特殊的文件，每个设备有FCB，设置访问权限

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775129991685)



#### 5.2.2 I/O设备假脱机技术

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775130243087)



1.什么是脱机技术？

**这里温习一下手工操作阶段：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775130454889)

* 因为手工阶段的速度慢问题，引入了脱机技术（用磁带作为CPU和纸带的中间设备）
* 外围控制机控制  纸带和磁带  之间关系
* ![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775130726191)



2.假脱机技术

> **脱机技术，是为了缓解CPU和设备之间的速度矛盾，实现预输入，缓输出**

* 在脱机技术的基础上人们发明了更好的假脱机技术

> 输入井和输出井(模拟磁带的作用，在磁盘上)

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775130984493)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775131236695)

**输入进程与输出进程（模拟外围控制机）**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775131466197)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-163775131812499)

**输入输出缓冲区**

输入设备——输入缓冲区（在内存中）——输入井（磁盘）

输出井——输出缓冲区（在内存中）——输出设备



![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751321285101)



**共享打印机原理分析—假脱机技术的一种应用**

**先了解一下独占和共享设备，以此引出假脱机技术如何实现对独占设备的共享：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751327054103)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751335806107)

* 打印请求完成后，请求表从打印队列删除，执行后续队列的打印任务

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751331372105)



#### 5.2.3 I/O设备的分配与回收

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751339781109)



1.设备分配时应该考虑的因素

**设备的固有属性**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751342069111)

**设备的分配算法**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751344054113)

**设备分配中的安全性**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751346227115)



2.静态分配与动态分配

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751349652117)



3.设备分配管理中的数据结构

**设备、控制器、通道之间的关系：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751353236119)

**设备控制表—DCT**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751355396121)

**控制器控制表—COCT**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751358980123)

**通道控制表—CHCT**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751361173125)

**系统设备表—SDT**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751363652127)



4.设备分配的步骤

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751365925129)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751368108131)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751370452133)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751372870135)

**设备分配的改进步骤**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751375436137)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751384020139)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751388333141)

#### 5.2.4 缓冲区管理

0.思维导图

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751390909143)



1.什么是缓冲区？有什么作用？

> 访问速度很快的存储器，一般用内存做为缓冲区
>
> 缓和CPU和IO设备速度不匹配的矛盾
>
> **缓存区满才可以发送，为空才可以充入**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751393796145)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751396612147)



2.单缓冲

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751399196149)
**T>C时的例子：**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751401348151)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751403581153)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751405820155)
**T<C时：**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751408284157)



3.双缓冲

**T>C+M时：**

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751412100159)
**T<C+M时：**
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751414540161)
![在这里插入图片描述](操作系统.assets/20200522110019682.png)



4.单缓冲和双缓冲通信时的区别

> 单缓冲只能实现数据的单向传输
>
> 双缓冲能实现数据的双向传输
>
> 管道技术一种缓存区，可以设置两个管道实现双向传输

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751418134163)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751420677165)



5.循环缓冲区

多个缓冲区，in和out指针

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751423564167)



6.缓冲池（类似线程池）

![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751426349169)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751429020171)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751431180173)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751433588175)
![在这里插入图片描述](操作系统.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-1637751436492177)

